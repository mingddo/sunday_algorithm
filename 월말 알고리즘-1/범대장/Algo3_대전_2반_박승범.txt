
<pseudocode>

해결 방식:

완전 탐색으로는 첫번째 학생이 아무거나 고르고 다음 행에서는 같은 열에서 고르지 못하도록
조건을 주고 학생수에 맞게 DFS알고리즘 방식으로 가능하다.
첫 번째 학생 부터 무늬가 겹치지 않은 카드 중 가장 작은 카드를 더 하여 총 합을 구해간다.
이런 조건만 주게 되면 결국 완전 탐색이 되지만 첫 번째로 출력되는 값을 min 값으로 정하고
그 뒤에 계속하여 실행되는 DFS의 값이 min값을 넘어가면 함수를 나가지게 하여
실행시간을 줄이는 방식으로 알고리즘을 짠다.

def pseudocode():
    global minValue
    if 마지막 학생수 초과:
        return
    elif 지금까지 더한 수 > minValue:
        continue
    for _ in range(4):
    .
    .
    .
    .

main function
minValue = 0

이런식으로 하게 된다면 최대 경우의 수인 {4 x 3 ^(학생수 -1)}보다
작은 경우의 수가 나올 것으로 예상된다.


